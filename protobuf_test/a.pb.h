// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: a.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_a_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_a_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3018000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3018000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_a_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_a_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[8]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_a_2eproto;
namespace Test {
class MapConfig;
struct MapConfigDefaultTypeInternal;
extern MapConfigDefaultTypeInternal _MapConfig_default_instance_;
class MapConfig_ConfigEntry_DoNotUse;
struct MapConfig_ConfigEntry_DoNotUseDefaultTypeInternal;
extern MapConfig_ConfigEntry_DoNotUseDefaultTypeInternal _MapConfig_ConfigEntry_DoNotUse_default_instance_;
class MapPath;
struct MapPathDefaultTypeInternal;
extern MapPathDefaultTypeInternal _MapPath_default_instance_;
class MapPath_ConfigEntry_DoNotUse;
struct MapPath_ConfigEntry_DoNotUseDefaultTypeInternal;
extern MapPath_ConfigEntry_DoNotUseDefaultTypeInternal _MapPath_ConfigEntry_DoNotUse_default_instance_;
class MsgPathUnit;
struct MsgPathUnitDefaultTypeInternal;
extern MsgPathUnitDefaultTypeInternal _MsgPathUnit_default_instance_;
class Path;
struct PathDefaultTypeInternal;
extern PathDefaultTypeInternal _Path_default_instance_;
class Paths;
struct PathsDefaultTypeInternal;
extern PathsDefaultTypeInternal _Paths_default_instance_;
class SpecConfig;
struct SpecConfigDefaultTypeInternal;
extern SpecConfigDefaultTypeInternal _SpecConfig_default_instance_;
}  // namespace Test
PROTOBUF_NAMESPACE_OPEN
template<> ::Test::MapConfig* Arena::CreateMaybeMessage<::Test::MapConfig>(Arena*);
template<> ::Test::MapConfig_ConfigEntry_DoNotUse* Arena::CreateMaybeMessage<::Test::MapConfig_ConfigEntry_DoNotUse>(Arena*);
template<> ::Test::MapPath* Arena::CreateMaybeMessage<::Test::MapPath>(Arena*);
template<> ::Test::MapPath_ConfigEntry_DoNotUse* Arena::CreateMaybeMessage<::Test::MapPath_ConfigEntry_DoNotUse>(Arena*);
template<> ::Test::MsgPathUnit* Arena::CreateMaybeMessage<::Test::MsgPathUnit>(Arena*);
template<> ::Test::Path* Arena::CreateMaybeMessage<::Test::Path>(Arena*);
template<> ::Test::Paths* Arena::CreateMaybeMessage<::Test::Paths>(Arena*);
template<> ::Test::SpecConfig* Arena::CreateMaybeMessage<::Test::SpecConfig>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Test {

enum PathFreq : int {
  HKLM = 0,
  HKCU = 1,
  HKCR = 2,
  HKU = 3,
  HKCC = 4,
  MODEL = 5,
  PRINTERNAME = 6,
  SMWCP = 7,
  resevered8 = 8,
  resevered9 = 9,
  resevered10 = 10,
  resevered11 = 11,
  resevered12 = 12,
  resevered13 = 13,
  resevered14 = 14,
  resevered15 = 15,
  resevered16 = 16,
  PathFreq_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PathFreq_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PathFreq_IsValid(int value);
constexpr PathFreq PathFreq_MIN = HKLM;
constexpr PathFreq PathFreq_MAX = resevered16;
constexpr int PathFreq_ARRAYSIZE = PathFreq_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PathFreq_descriptor();
template<typename T>
inline const std::string& PathFreq_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PathFreq>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PathFreq_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PathFreq_descriptor(), enum_t_value);
}
inline bool PathFreq_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PathFreq* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PathFreq>(
    PathFreq_descriptor(), name, value);
}
// ===================================================================

class MsgPathUnit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Test.MsgPathUnit) */ {
 public:
  inline MsgPathUnit() : MsgPathUnit(nullptr) {}
  ~MsgPathUnit() override;
  explicit constexpr MsgPathUnit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgPathUnit(const MsgPathUnit& from);
  MsgPathUnit(MsgPathUnit&& from) noexcept
    : MsgPathUnit() {
    *this = ::std::move(from);
  }

  inline MsgPathUnit& operator=(const MsgPathUnit& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgPathUnit& operator=(MsgPathUnit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgPathUnit& default_instance() {
    return *internal_default_instance();
  }
  enum PathUnitCase {
    kFreq = 1,
    kNormal = 2,
    PATHUNIT_NOT_SET = 0,
  };

  static inline const MsgPathUnit* internal_default_instance() {
    return reinterpret_cast<const MsgPathUnit*>(
               &_MsgPathUnit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(MsgPathUnit& a, MsgPathUnit& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgPathUnit* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgPathUnit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MsgPathUnit* New() const final {
    return new MsgPathUnit();
  }

  MsgPathUnit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MsgPathUnit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgPathUnit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MsgPathUnit& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgPathUnit* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Test.MsgPathUnit";
  }
  protected:
  explicit MsgPathUnit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFreqFieldNumber = 1,
    kNormalFieldNumber = 2,
  };
  // .Test.PathFreq freq = 1;
  bool has_freq() const;
  private:
  bool _internal_has_freq() const;
  public:
  void clear_freq();
  ::Test::PathFreq freq() const;
  void set_freq(::Test::PathFreq value);
  private:
  ::Test::PathFreq _internal_freq() const;
  void _internal_set_freq(::Test::PathFreq value);
  public:

  // string normal = 2;
  bool has_normal() const;
  private:
  bool _internal_has_normal() const;
  public:
  void clear_normal();
  const std::string& normal() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_normal(ArgT0&& arg0, ArgT... args);
  std::string* mutable_normal();
  PROTOBUF_MUST_USE_RESULT std::string* release_normal();
  void set_allocated_normal(std::string* normal);
  private:
  const std::string& _internal_normal() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_normal(const std::string& value);
  std::string* _internal_mutable_normal();
  public:

  void clear_PathUnit();
  PathUnitCase PathUnit_case() const;
  // @@protoc_insertion_point(class_scope:Test.MsgPathUnit)
 private:
  class _Internal;
  void set_has_freq();
  void set_has_normal();

  inline bool has_PathUnit() const;
  inline void clear_has_PathUnit();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union PathUnitUnion {
    constexpr PathUnitUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    int freq_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr normal_;
  } PathUnit_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_a_2eproto;
};
// -------------------------------------------------------------------

class Path final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Test.Path) */ {
 public:
  inline Path() : Path(nullptr) {}
  ~Path() override;
  explicit constexpr Path(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Path(const Path& from);
  Path(Path&& from) noexcept
    : Path() {
    *this = ::std::move(from);
  }

  inline Path& operator=(const Path& from) {
    CopyFrom(from);
    return *this;
  }
  inline Path& operator=(Path&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Path& default_instance() {
    return *internal_default_instance();
  }
  static inline const Path* internal_default_instance() {
    return reinterpret_cast<const Path*>(
               &_Path_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Path& a, Path& b) {
    a.Swap(&b);
  }
  inline void Swap(Path* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Path* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Path* New() const final {
    return new Path();
  }

  Path* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Path>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Path& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Path& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Path* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Test.Path";
  }
  protected:
  explicit Path(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUnitFieldNumber = 1,
  };
  // repeated .Test.MsgPathUnit unit = 1;
  int unit_size() const;
  private:
  int _internal_unit_size() const;
  public:
  void clear_unit();
  ::Test::MsgPathUnit* mutable_unit(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Test::MsgPathUnit >*
      mutable_unit();
  private:
  const ::Test::MsgPathUnit& _internal_unit(int index) const;
  ::Test::MsgPathUnit* _internal_add_unit();
  public:
  const ::Test::MsgPathUnit& unit(int index) const;
  ::Test::MsgPathUnit* add_unit();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Test::MsgPathUnit >&
      unit() const;

  // @@protoc_insertion_point(class_scope:Test.Path)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Test::MsgPathUnit > unit_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_a_2eproto;
};
// -------------------------------------------------------------------

class MapPath_ConfigEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<MapPath_ConfigEntry_DoNotUse, 
    ::PROTOBUF_NAMESPACE_ID::uint32, ::Test::Path,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<MapPath_ConfigEntry_DoNotUse, 
    ::PROTOBUF_NAMESPACE_ID::uint32, ::Test::Path,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  MapPath_ConfigEntry_DoNotUse();
  explicit constexpr MapPath_ConfigEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit MapPath_ConfigEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const MapPath_ConfigEntry_DoNotUse& other);
  static const MapPath_ConfigEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const MapPath_ConfigEntry_DoNotUse*>(&_MapPath_ConfigEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class MapPath final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Test.MapPath) */ {
 public:
  inline MapPath() : MapPath(nullptr) {}
  ~MapPath() override;
  explicit constexpr MapPath(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MapPath(const MapPath& from);
  MapPath(MapPath&& from) noexcept
    : MapPath() {
    *this = ::std::move(from);
  }

  inline MapPath& operator=(const MapPath& from) {
    CopyFrom(from);
    return *this;
  }
  inline MapPath& operator=(MapPath&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MapPath& default_instance() {
    return *internal_default_instance();
  }
  static inline const MapPath* internal_default_instance() {
    return reinterpret_cast<const MapPath*>(
               &_MapPath_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(MapPath& a, MapPath& b) {
    a.Swap(&b);
  }
  inline void Swap(MapPath* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MapPath* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MapPath* New() const final {
    return new MapPath();
  }

  MapPath* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MapPath>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MapPath& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MapPath& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MapPath* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Test.MapPath";
  }
  protected:
  explicit MapPath(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kConfigFieldNumber = 1,
  };
  // map<uint32, .Test.Path> Config = 1;
  int config_size() const;
  private:
  int _internal_config_size() const;
  public:
  void clear_config();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint32, ::Test::Path >&
      _internal_config() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint32, ::Test::Path >*
      _internal_mutable_config();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint32, ::Test::Path >&
      config() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint32, ::Test::Path >*
      mutable_config();

  // @@protoc_insertion_point(class_scope:Test.MapPath)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      MapPath_ConfigEntry_DoNotUse,
      ::PROTOBUF_NAMESPACE_ID::uint32, ::Test::Path,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> config_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_a_2eproto;
};
// -------------------------------------------------------------------

class Paths final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Test.Paths) */ {
 public:
  inline Paths() : Paths(nullptr) {}
  ~Paths() override;
  explicit constexpr Paths(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Paths(const Paths& from);
  Paths(Paths&& from) noexcept
    : Paths() {
    *this = ::std::move(from);
  }

  inline Paths& operator=(const Paths& from) {
    CopyFrom(from);
    return *this;
  }
  inline Paths& operator=(Paths&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Paths& default_instance() {
    return *internal_default_instance();
  }
  static inline const Paths* internal_default_instance() {
    return reinterpret_cast<const Paths*>(
               &_Paths_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Paths& a, Paths& b) {
    a.Swap(&b);
  }
  inline void Swap(Paths* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Paths* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Paths* New() const final {
    return new Paths();
  }

  Paths* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Paths>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Paths& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Paths& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Paths* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Test.Paths";
  }
  protected:
  explicit Paths(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPFieldNumber = 1,
  };
  // repeated uint32 p = 1;
  int p_size() const;
  private:
  int _internal_p_size() const;
  public:
  void clear_p();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_p(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      _internal_p() const;
  void _internal_add_p(::PROTOBUF_NAMESPACE_ID::uint32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      _internal_mutable_p();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint32 p(int index) const;
  void set_p(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value);
  void add_p(::PROTOBUF_NAMESPACE_ID::uint32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      p() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      mutable_p();

  // @@protoc_insertion_point(class_scope:Test.Paths)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 > p_;
  mutable std::atomic<int> _p_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_a_2eproto;
};
// -------------------------------------------------------------------

class MapConfig_ConfigEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<MapConfig_ConfigEntry_DoNotUse, 
    std::string, ::Test::Paths,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<MapConfig_ConfigEntry_DoNotUse, 
    std::string, ::Test::Paths,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  MapConfig_ConfigEntry_DoNotUse();
  explicit constexpr MapConfig_ConfigEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit MapConfig_ConfigEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const MapConfig_ConfigEntry_DoNotUse& other);
  static const MapConfig_ConfigEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const MapConfig_ConfigEntry_DoNotUse*>(&_MapConfig_ConfigEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "Test.MapConfig.ConfigEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class MapConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Test.MapConfig) */ {
 public:
  inline MapConfig() : MapConfig(nullptr) {}
  ~MapConfig() override;
  explicit constexpr MapConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MapConfig(const MapConfig& from);
  MapConfig(MapConfig&& from) noexcept
    : MapConfig() {
    *this = ::std::move(from);
  }

  inline MapConfig& operator=(const MapConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline MapConfig& operator=(MapConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MapConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const MapConfig* internal_default_instance() {
    return reinterpret_cast<const MapConfig*>(
               &_MapConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(MapConfig& a, MapConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(MapConfig* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MapConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MapConfig* New() const final {
    return new MapConfig();
  }

  MapConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MapConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MapConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MapConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MapConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Test.MapConfig";
  }
  protected:
  explicit MapConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kConfigFieldNumber = 1,
  };
  // map<string, .Test.Paths> Config = 1;
  int config_size() const;
  private:
  int _internal_config_size() const;
  public:
  void clear_config();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::Test::Paths >&
      _internal_config() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::Test::Paths >*
      _internal_mutable_config();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::Test::Paths >&
      config() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::Test::Paths >*
      mutable_config();

  // @@protoc_insertion_point(class_scope:Test.MapConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      MapConfig_ConfigEntry_DoNotUse,
      std::string, ::Test::Paths,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> config_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_a_2eproto;
};
// -------------------------------------------------------------------

class SpecConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Test.SpecConfig) */ {
 public:
  inline SpecConfig() : SpecConfig(nullptr) {}
  ~SpecConfig() override;
  explicit constexpr SpecConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpecConfig(const SpecConfig& from);
  SpecConfig(SpecConfig&& from) noexcept
    : SpecConfig() {
    *this = ::std::move(from);
  }

  inline SpecConfig& operator=(const SpecConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpecConfig& operator=(SpecConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpecConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpecConfig* internal_default_instance() {
    return reinterpret_cast<const SpecConfig*>(
               &_SpecConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SpecConfig& a, SpecConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(SpecConfig* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpecConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SpecConfig* New() const final {
    return new SpecConfig();
  }

  SpecConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SpecConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SpecConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SpecConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpecConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Test.SpecConfig";
  }
  protected:
  explicit SpecConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSFieldNumber = 1,
    kMappathFieldNumber = 2,
    kMapconfigFieldNumber = 3,
  };
  // string s = 1;
  void clear_s();
  const std::string& s() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_s(ArgT0&& arg0, ArgT... args);
  std::string* mutable_s();
  PROTOBUF_MUST_USE_RESULT std::string* release_s();
  void set_allocated_s(std::string* s);
  private:
  const std::string& _internal_s() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_s(const std::string& value);
  std::string* _internal_mutable_s();
  public:

  // .Test.MapPath mappath = 2;
  bool has_mappath() const;
  private:
  bool _internal_has_mappath() const;
  public:
  void clear_mappath();
  const ::Test::MapPath& mappath() const;
  PROTOBUF_MUST_USE_RESULT ::Test::MapPath* release_mappath();
  ::Test::MapPath* mutable_mappath();
  void set_allocated_mappath(::Test::MapPath* mappath);
  private:
  const ::Test::MapPath& _internal_mappath() const;
  ::Test::MapPath* _internal_mutable_mappath();
  public:
  void unsafe_arena_set_allocated_mappath(
      ::Test::MapPath* mappath);
  ::Test::MapPath* unsafe_arena_release_mappath();

  // .Test.MapConfig mapconfig = 3;
  bool has_mapconfig() const;
  private:
  bool _internal_has_mapconfig() const;
  public:
  void clear_mapconfig();
  const ::Test::MapConfig& mapconfig() const;
  PROTOBUF_MUST_USE_RESULT ::Test::MapConfig* release_mapconfig();
  ::Test::MapConfig* mutable_mapconfig();
  void set_allocated_mapconfig(::Test::MapConfig* mapconfig);
  private:
  const ::Test::MapConfig& _internal_mapconfig() const;
  ::Test::MapConfig* _internal_mutable_mapconfig();
  public:
  void unsafe_arena_set_allocated_mapconfig(
      ::Test::MapConfig* mapconfig);
  ::Test::MapConfig* unsafe_arena_release_mapconfig();

  // @@protoc_insertion_point(class_scope:Test.SpecConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr s_;
  ::Test::MapPath* mappath_;
  ::Test::MapConfig* mapconfig_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_a_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MsgPathUnit

// .Test.PathFreq freq = 1;
inline bool MsgPathUnit::_internal_has_freq() const {
  return PathUnit_case() == kFreq;
}
inline bool MsgPathUnit::has_freq() const {
  return _internal_has_freq();
}
inline void MsgPathUnit::set_has_freq() {
  _oneof_case_[0] = kFreq;
}
inline void MsgPathUnit::clear_freq() {
  if (_internal_has_freq()) {
    PathUnit_.freq_ = 0;
    clear_has_PathUnit();
  }
}
inline ::Test::PathFreq MsgPathUnit::_internal_freq() const {
  if (_internal_has_freq()) {
    return static_cast< ::Test::PathFreq >(PathUnit_.freq_);
  }
  return static_cast< ::Test::PathFreq >(0);
}
inline ::Test::PathFreq MsgPathUnit::freq() const {
  // @@protoc_insertion_point(field_get:Test.MsgPathUnit.freq)
  return _internal_freq();
}
inline void MsgPathUnit::_internal_set_freq(::Test::PathFreq value) {
  if (!_internal_has_freq()) {
    clear_PathUnit();
    set_has_freq();
  }
  PathUnit_.freq_ = value;
}
inline void MsgPathUnit::set_freq(::Test::PathFreq value) {
  _internal_set_freq(value);
  // @@protoc_insertion_point(field_set:Test.MsgPathUnit.freq)
}

// string normal = 2;
inline bool MsgPathUnit::_internal_has_normal() const {
  return PathUnit_case() == kNormal;
}
inline bool MsgPathUnit::has_normal() const {
  return _internal_has_normal();
}
inline void MsgPathUnit::set_has_normal() {
  _oneof_case_[0] = kNormal;
}
inline void MsgPathUnit::clear_normal() {
  if (_internal_has_normal()) {
    PathUnit_.normal_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_PathUnit();
  }
}
inline const std::string& MsgPathUnit::normal() const {
  // @@protoc_insertion_point(field_get:Test.MsgPathUnit.normal)
  return _internal_normal();
}
template <typename ArgT0, typename... ArgT>
inline void MsgPathUnit::set_normal(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_normal()) {
    clear_PathUnit();
    set_has_normal();
    PathUnit_.normal_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  PathUnit_.normal_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Test.MsgPathUnit.normal)
}
inline std::string* MsgPathUnit::mutable_normal() {
  std::string* _s = _internal_mutable_normal();
  // @@protoc_insertion_point(field_mutable:Test.MsgPathUnit.normal)
  return _s;
}
inline const std::string& MsgPathUnit::_internal_normal() const {
  if (_internal_has_normal()) {
    return PathUnit_.normal_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void MsgPathUnit::_internal_set_normal(const std::string& value) {
  if (!_internal_has_normal()) {
    clear_PathUnit();
    set_has_normal();
    PathUnit_.normal_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  PathUnit_.normal_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MsgPathUnit::_internal_mutable_normal() {
  if (!_internal_has_normal()) {
    clear_PathUnit();
    set_has_normal();
    PathUnit_.normal_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return PathUnit_.normal_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MsgPathUnit::release_normal() {
  // @@protoc_insertion_point(field_release:Test.MsgPathUnit.normal)
  if (_internal_has_normal()) {
    clear_has_PathUnit();
    return PathUnit_.normal_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void MsgPathUnit::set_allocated_normal(std::string* normal) {
  if (has_PathUnit()) {
    clear_PathUnit();
  }
  if (normal != nullptr) {
    set_has_normal();
    PathUnit_.normal_.UnsafeSetDefault(normal);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(normal);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:Test.MsgPathUnit.normal)
}

inline bool MsgPathUnit::has_PathUnit() const {
  return PathUnit_case() != PATHUNIT_NOT_SET;
}
inline void MsgPathUnit::clear_has_PathUnit() {
  _oneof_case_[0] = PATHUNIT_NOT_SET;
}
inline MsgPathUnit::PathUnitCase MsgPathUnit::PathUnit_case() const {
  return MsgPathUnit::PathUnitCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Path

// repeated .Test.MsgPathUnit unit = 1;
inline int Path::_internal_unit_size() const {
  return unit_.size();
}
inline int Path::unit_size() const {
  return _internal_unit_size();
}
inline void Path::clear_unit() {
  unit_.Clear();
}
inline ::Test::MsgPathUnit* Path::mutable_unit(int index) {
  // @@protoc_insertion_point(field_mutable:Test.Path.unit)
  return unit_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Test::MsgPathUnit >*
Path::mutable_unit() {
  // @@protoc_insertion_point(field_mutable_list:Test.Path.unit)
  return &unit_;
}
inline const ::Test::MsgPathUnit& Path::_internal_unit(int index) const {
  return unit_.Get(index);
}
inline const ::Test::MsgPathUnit& Path::unit(int index) const {
  // @@protoc_insertion_point(field_get:Test.Path.unit)
  return _internal_unit(index);
}
inline ::Test::MsgPathUnit* Path::_internal_add_unit() {
  return unit_.Add();
}
inline ::Test::MsgPathUnit* Path::add_unit() {
  ::Test::MsgPathUnit* _add = _internal_add_unit();
  // @@protoc_insertion_point(field_add:Test.Path.unit)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Test::MsgPathUnit >&
Path::unit() const {
  // @@protoc_insertion_point(field_list:Test.Path.unit)
  return unit_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// MapPath

// map<uint32, .Test.Path> Config = 1;
inline int MapPath::_internal_config_size() const {
  return config_.size();
}
inline int MapPath::config_size() const {
  return _internal_config_size();
}
inline void MapPath::clear_config() {
  config_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint32, ::Test::Path >&
MapPath::_internal_config() const {
  return config_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint32, ::Test::Path >&
MapPath::config() const {
  // @@protoc_insertion_point(field_map:Test.MapPath.Config)
  return _internal_config();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint32, ::Test::Path >*
MapPath::_internal_mutable_config() {
  return config_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint32, ::Test::Path >*
MapPath::mutable_config() {
  // @@protoc_insertion_point(field_mutable_map:Test.MapPath.Config)
  return _internal_mutable_config();
}

// -------------------------------------------------------------------

// Paths

// repeated uint32 p = 1;
inline int Paths::_internal_p_size() const {
  return p_.size();
}
inline int Paths::p_size() const {
  return _internal_p_size();
}
inline void Paths::clear_p() {
  p_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Paths::_internal_p(int index) const {
  return p_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Paths::p(int index) const {
  // @@protoc_insertion_point(field_get:Test.Paths.p)
  return _internal_p(index);
}
inline void Paths::set_p(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value) {
  p_.Set(index, value);
  // @@protoc_insertion_point(field_set:Test.Paths.p)
}
inline void Paths::_internal_add_p(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  p_.Add(value);
}
inline void Paths::add_p(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_add_p(value);
  // @@protoc_insertion_point(field_add:Test.Paths.p)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
Paths::_internal_p() const {
  return p_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
Paths::p() const {
  // @@protoc_insertion_point(field_list:Test.Paths.p)
  return _internal_p();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
Paths::_internal_mutable_p() {
  return &p_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
Paths::mutable_p() {
  // @@protoc_insertion_point(field_mutable_list:Test.Paths.p)
  return _internal_mutable_p();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// MapConfig

// map<string, .Test.Paths> Config = 1;
inline int MapConfig::_internal_config_size() const {
  return config_.size();
}
inline int MapConfig::config_size() const {
  return _internal_config_size();
}
inline void MapConfig::clear_config() {
  config_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::Test::Paths >&
MapConfig::_internal_config() const {
  return config_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::Test::Paths >&
MapConfig::config() const {
  // @@protoc_insertion_point(field_map:Test.MapConfig.Config)
  return _internal_config();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::Test::Paths >*
MapConfig::_internal_mutable_config() {
  return config_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::Test::Paths >*
MapConfig::mutable_config() {
  // @@protoc_insertion_point(field_mutable_map:Test.MapConfig.Config)
  return _internal_mutable_config();
}

// -------------------------------------------------------------------

// SpecConfig

// string s = 1;
inline void SpecConfig::clear_s() {
  s_.ClearToEmpty();
}
inline const std::string& SpecConfig::s() const {
  // @@protoc_insertion_point(field_get:Test.SpecConfig.s)
  return _internal_s();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SpecConfig::set_s(ArgT0&& arg0, ArgT... args) {
 
 s_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Test.SpecConfig.s)
}
inline std::string* SpecConfig::mutable_s() {
  std::string* _s = _internal_mutable_s();
  // @@protoc_insertion_point(field_mutable:Test.SpecConfig.s)
  return _s;
}
inline const std::string& SpecConfig::_internal_s() const {
  return s_.Get();
}
inline void SpecConfig::_internal_set_s(const std::string& value) {
  
  s_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SpecConfig::_internal_mutable_s() {
  
  return s_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SpecConfig::release_s() {
  // @@protoc_insertion_point(field_release:Test.SpecConfig.s)
  return s_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SpecConfig::set_allocated_s(std::string* s) {
  if (s != nullptr) {
    
  } else {
    
  }
  s_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), s,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:Test.SpecConfig.s)
}

// .Test.MapPath mappath = 2;
inline bool SpecConfig::_internal_has_mappath() const {
  return this != internal_default_instance() && mappath_ != nullptr;
}
inline bool SpecConfig::has_mappath() const {
  return _internal_has_mappath();
}
inline void SpecConfig::clear_mappath() {
  if (GetArenaForAllocation() == nullptr && mappath_ != nullptr) {
    delete mappath_;
  }
  mappath_ = nullptr;
}
inline const ::Test::MapPath& SpecConfig::_internal_mappath() const {
  const ::Test::MapPath* p = mappath_;
  return p != nullptr ? *p : reinterpret_cast<const ::Test::MapPath&>(
      ::Test::_MapPath_default_instance_);
}
inline const ::Test::MapPath& SpecConfig::mappath() const {
  // @@protoc_insertion_point(field_get:Test.SpecConfig.mappath)
  return _internal_mappath();
}
inline void SpecConfig::unsafe_arena_set_allocated_mappath(
    ::Test::MapPath* mappath) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mappath_);
  }
  mappath_ = mappath;
  if (mappath) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Test.SpecConfig.mappath)
}
inline ::Test::MapPath* SpecConfig::release_mappath() {
  
  ::Test::MapPath* temp = mappath_;
  mappath_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Test::MapPath* SpecConfig::unsafe_arena_release_mappath() {
  // @@protoc_insertion_point(field_release:Test.SpecConfig.mappath)
  
  ::Test::MapPath* temp = mappath_;
  mappath_ = nullptr;
  return temp;
}
inline ::Test::MapPath* SpecConfig::_internal_mutable_mappath() {
  
  if (mappath_ == nullptr) {
    auto* p = CreateMaybeMessage<::Test::MapPath>(GetArenaForAllocation());
    mappath_ = p;
  }
  return mappath_;
}
inline ::Test::MapPath* SpecConfig::mutable_mappath() {
  ::Test::MapPath* _msg = _internal_mutable_mappath();
  // @@protoc_insertion_point(field_mutable:Test.SpecConfig.mappath)
  return _msg;
}
inline void SpecConfig::set_allocated_mappath(::Test::MapPath* mappath) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete mappath_;
  }
  if (mappath) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Test::MapPath>::GetOwningArena(mappath);
    if (message_arena != submessage_arena) {
      mappath = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mappath, submessage_arena);
    }
    
  } else {
    
  }
  mappath_ = mappath;
  // @@protoc_insertion_point(field_set_allocated:Test.SpecConfig.mappath)
}

// .Test.MapConfig mapconfig = 3;
inline bool SpecConfig::_internal_has_mapconfig() const {
  return this != internal_default_instance() && mapconfig_ != nullptr;
}
inline bool SpecConfig::has_mapconfig() const {
  return _internal_has_mapconfig();
}
inline void SpecConfig::clear_mapconfig() {
  if (GetArenaForAllocation() == nullptr && mapconfig_ != nullptr) {
    delete mapconfig_;
  }
  mapconfig_ = nullptr;
}
inline const ::Test::MapConfig& SpecConfig::_internal_mapconfig() const {
  const ::Test::MapConfig* p = mapconfig_;
  return p != nullptr ? *p : reinterpret_cast<const ::Test::MapConfig&>(
      ::Test::_MapConfig_default_instance_);
}
inline const ::Test::MapConfig& SpecConfig::mapconfig() const {
  // @@protoc_insertion_point(field_get:Test.SpecConfig.mapconfig)
  return _internal_mapconfig();
}
inline void SpecConfig::unsafe_arena_set_allocated_mapconfig(
    ::Test::MapConfig* mapconfig) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mapconfig_);
  }
  mapconfig_ = mapconfig;
  if (mapconfig) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Test.SpecConfig.mapconfig)
}
inline ::Test::MapConfig* SpecConfig::release_mapconfig() {
  
  ::Test::MapConfig* temp = mapconfig_;
  mapconfig_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Test::MapConfig* SpecConfig::unsafe_arena_release_mapconfig() {
  // @@protoc_insertion_point(field_release:Test.SpecConfig.mapconfig)
  
  ::Test::MapConfig* temp = mapconfig_;
  mapconfig_ = nullptr;
  return temp;
}
inline ::Test::MapConfig* SpecConfig::_internal_mutable_mapconfig() {
  
  if (mapconfig_ == nullptr) {
    auto* p = CreateMaybeMessage<::Test::MapConfig>(GetArenaForAllocation());
    mapconfig_ = p;
  }
  return mapconfig_;
}
inline ::Test::MapConfig* SpecConfig::mutable_mapconfig() {
  ::Test::MapConfig* _msg = _internal_mutable_mapconfig();
  // @@protoc_insertion_point(field_mutable:Test.SpecConfig.mapconfig)
  return _msg;
}
inline void SpecConfig::set_allocated_mapconfig(::Test::MapConfig* mapconfig) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete mapconfig_;
  }
  if (mapconfig) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Test::MapConfig>::GetOwningArena(mapconfig);
    if (message_arena != submessage_arena) {
      mapconfig = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mapconfig, submessage_arena);
    }
    
  } else {
    
  }
  mapconfig_ = mapconfig;
  // @@protoc_insertion_point(field_set_allocated:Test.SpecConfig.mapconfig)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Test

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::Test::PathFreq> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Test::PathFreq>() {
  return ::Test::PathFreq_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_a_2eproto
